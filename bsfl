#!/bin/bash
# ###########################
# Bash Shell Function Library
# ###########################
#
# Author: Louwrentius <louwrentius@gmail.com>
# Maintainer: Peter Boling <peter.boling@gmail.com>
# Contributions by: Jani Hurskainen
#
# Copyright Â© 2010
#
# Released under the current GPL version.
#
# Description:
#
# This is a shell script library. It contains functions that can be called by
# programs that include (source) this library.
#
# By simply sourcing this library, you can use all available functions as
# documented on the projects page.
#
#

BSFL_VERSION="2.00-beta-7"

#
# Do not edit this file. Just source it into your script
# and override the variables to change their value.
#

init () {

    #
    # Debug mode shows more verbose output to screen and log files.
    # Value: yes or no (y / n)
    #
    DEBUG=no

    # How far to the right should be considered too far to print?
    declare -i max_cols=$(tput cols)
    TRIM_LENGTH=max_cols-20

    #
    # Syslog style log messages
    #
    if ! defined LOGDATEFORMAT
    then
        LOGDATEFORMAT="%b %e %H:%M:%S"
    fi
    if ! defined LOG_FILE
    then
        LOG_FILE=$0.log
    fi

    #
    # Enable / disable logging to a file
    # Value: yes or no (y / n)
    #
    if ! defined LOG_ENABLED
    then
        LOG_ENABLED=no
    fi
    if ! defined SYSLOG_ENABLED
    then
        SYSLOG_ENABLED=no
    fi
    if ! defined SYSLOG_TAG
    then
        SYSLOG_TAG=$0
    fi

    #
    # Use colours in output.
    #
    RED="tput setaf 1"
    GREEN="tput setaf 2"
    YELLOW="tput setaf 3"
    BLUE="tput setaf 4"
    MAGENTA="tput setaf 5"
    CYAN="tput setaf 6"
    LIGHT_BLUE="$CYAN"
    BOLD="tput bold"
    DEFAULT="tput sgr0"

    RED_BG="tput setab 1"
    GREEN_BG="tput setab 2"
    YELLOW_BG="tput setab 3"
    BLUE_BG="tput setab 4"
    MAGENTA_BG="tput setab 5"
    CYAN_BG="tput setab 6"

    #
    # Bug fix for Bash, parsing exclamation mark.
    #
    set +o histexpand
    #
    # returns 0 if a variable is defined (set)
    # returns 1 if a variable is unset
    #

    # Is this going to run in a color capable terminal?
    BOOTUP=color
    STEP_COL=70
    MOVE_TO_COL="echo -en \\033[${STEP_COL}G"
    SETCOLOR_SUCCESS="echo -en \\033[1;32m"
    SETCOLOR_FAILURE="echo -en \\033[1;31m"
    SETCOLOR_WARNING="echo -en \\033[1;33m"
    SETCOLOR_NORMAL="echo -en \\033[0;39m"
}

function defined {
    [[ ${!1-X} == ${!1-Y} ]]
}

#
# returns 0 if a variable is defined (set) and value's length > 0
# returns 1 otherwise
#
function has_value {
    if defined $1; then
        if [[ -n ${!1} ]]; then
            return 0
        fi
    fi
    return 1
}

# has an exported, not-null, value
function has_exported_value {
    var=$1
    re='^declare -\w*x'
    if [[ ! -z "${!var}" ]]; then
#    if [[ -n $(eval echo \$$1) ]] && [[ $(declare -p "$1") =~ $re ]]; then
        return 0
    fi
    return 1
}

#
# returns 0 if a directory exists
# returns 1 otherwise
#
function directory_exists {
    if [[ -d "$1" ]]; then
        return 0
    fi
    return 1
}

#
# returns 0 if a (regular) file exists
# returns 1 otherwise
#
function file_exists {
    if [[ -f "$1" ]]; then
        return 0
    fi
    return 1
}

#
# returns lowercase string
#
function tolower {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

#
# returns uppercase string
#
function toupper {
    echo "$1" | tr '[:lower:]' '[:upper:]'
}

#
# Only returns the first part of a string, delimited by tabs or spaces
#
function trim {
    echo $1
}

#
# Dummy function to provide usage instructions.
# Override this function if required.
#
show_usage () {

    MESSAGE="$1"
    echo "$MESSAGE"
    exit 1
}

#
# Checks if a variable is set to "y" or "yes".
# Usefull for detecting if a configurable option is set or not.
#
option_enabled () {

    VAR="$1"
    VAR_VALUE=$(eval echo \$$VAR)
    if [[ "$VAR_VALUE" == "y" ]] || [[ "$VAR_VALUE" == "yes" ]]
    then
        return 0
    else
        return 1
    fi
}

#
# The log function just puts a string into a file, prepended with a date & time in
# syslog format.
#

log2syslog () {

    if option_enabled  SYSLOG_ENABLED
    then
       MESSAGE="$1"
       logger -t "$SYSLOG_TAG" " $MESSAGE" #The space is not a typo!"
    fi
}

#
# This function writes messages to a log file and/or syslog
# The only argument is a message that has to be logged.
#

log () {

    if option_enabled LOG_ENABLED || option_enabled SYSLOG_ENABLED
    then
        LOG_MESSAGE="$1"
        DATE=`date +"$LOGDATEFORMAT"`

        if has_value LOG_MESSAGE
        then
            LOG_STRING="$DATE $LOG_MESSAGE"
        else
            LOG_STRING="$DATE -- empty log message, no input received --"
        fi

        if option_enabled LOG_ENABLED
        then
            echo "$LOG_STRING" >> "$LOG_FILE"
        fi

        if option_enabled SYSLOG_ENABLED
        then
            #
            # Syslog already prepends a date/time stamp so only the message
            # is logged.
            #
            log2syslog "$LOG_MESSAGE"
        fi
    fi
}

# echo_success and echo_fail will just print [ DING ] or [ BOOM ] after the end of the current line.
echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n $" DING "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\n"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n $" BOOM "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\n"
  return 1
}

#
# This function basically replaces the 'echo' function in bash scripts.
# The added functionality over echo is logging and using colors.
#
# The first argument is the string / message that must be displayed.
# The second argument is the text color.

msg () {

    MESSAGE="$1"
    COLOR="$2"
    if ! has_value COLOR
    then
        COLOR="$DEFAULT"
    fi

    if has_value "MESSAGE"
    then
        $COLOR
        if [ "$ERROR" != '0' ]; then
          # When it is an error show the whole chicken.
          echo "${MESSAGE}"
        else
          echo "${MESSAGE:0:$TRIM_LENGTH}..."
        fi
        $DEFAULT
        log "$MESSAGE"
    else
        echo "-- no message received --"
        log "$MESSAGE"
    fi
}

#
# This function echos a message
# and displays the status at the end of the line.
#
# It can be used to create status messages other
# than the default messages available such as
# OK or FAIL
#
msg_status () {

    MESSAGE="$1"
    STATUS="$2"

    # Move cursor to column #1
    tput hpa
    # Clear to beginning of line, because the command will be rewritten
    tput el1

    msg "$MESSAGE"
    display_status "$STATUS"
}

#
# These functions are just short hand for messages like
# msg_status "this message is ok" OK
#

#
# The following functions are shorthand for
# msg_status "a message" OK
# msg_status "another message" FAIL


msg_emergency () {

    MESSAGE="$1"
    STATUS="EMERGENCY"
    msg_status "$MESSAGE" "$STATUS"
}

msg_alert () {

    MESSAGE="$1"
    STATUS="ALERT"
    msg_status "$MESSAGE" "$STATUS"
}

msg_critical () {

    MESSAGE="$1"
    STATUS="CRITICAL"
    msg_status "$MESSAGE" "$STATUS"
}

msg_error () {

    MESSAGE="$1"
    STATUS="ERROR"
    msg_status "$MESSAGE" "$STATUS"
}

msg_warning () {

    MESSAGE="$1"
    STATUS="WARNING"
    msg_status "$MESSAGE" "$STATUS"
}

msg_notice () {
    MESSAGE="$1"
    STATUS="NOTICE"
    msg_status "$MESSAGE" "$STATUS"
}

msg_info () {
    MESSAGE="$1"
    STATUS="INFO"
    msg_status "$MESSAGE" "$STATUS"
}

msg_debug () {
    MESSAGE="$1"
    STATUS="DEBUG"
    msg_status "$MESSAGE" "$STATUS"
}

msg_ok () {

    MESSAGE="$1"
    STATUS="OK"
    msg_status "$MESSAGE" "$STATUS"
}

msg_not_ok () {

    MESSAGE="$1"
    STATUS="NOT_OK"
    msg_status "$MESSAGE" "$STATUS"
}

msg_fail () {

    MESSAGE="$1"
    STATUS="FAILED"
    msg_status "$MESSAGE" "$STATUS"
}

msg_success () {
    MESSAGE="$1"
    STATUS="SUCCESS"
    msg_status "$MESSAGE" "$STATUS"
}

msg_passed () {
    MESSAGE="$1"
    STATUS="PASSED"
    msg_status "$MESSAGE" "$STATUS"
}

check_status () {

    CMD="$1"
    STATUS="$2"

    # Stamp on the same line as the command.
    tput cuu1

    if [ "$STATUS" == "0" ]
    then
        msg_ok "$CMD"
    else
        msg_fail "$CMD"
    fi
}

#
# Private function
#
# This is a function that just positions
# the cursor one row up and to the right.
# It then prints a message with specified
# Color
# It is used for inserting colored status messages in front of the current line of text
#
# ARG1 = "status message (OK / FAIL)"
# ARG2 = The color in which the status is displayed.
#
raw_status () {

    STATUS="$1"
    COLOR="$2"

    function position_cursor () {

        # Move cursor to column #1
        tput hpa
        tput smir
        tput cuu1
    }

    position_cursor
    echo -n "["
    $DEFAULT
    $BOLD
    $COLOR
    echo -n "$STATUS"
    $DEFAULT
    echo "]"
    tput rmir
    log "Status = $STATUS"
}

#
# This function converts a status message to a particular color.
#
display_status () {

    STATUS="$1"

    case $STATUS in

    EMERGENCY )
            STATUS="EMERGENCY"
            COLOR="$RED"
            ;;
    ALERT )
            STATUS="  ALERT  "
            COLOR="$RED"
            ;;
    CRITICAL )
            STATUS="CRITICAL "
            COLOR="$RED"
            ;;
    ERROR )
            STATUS="  ERROR  "
            COLOR="$RED"
            ;;

    WARNING )
            STATUS=" WARNING "
            COLOR="$YELLOW"
            ;;

    NOTICE )
            STATUS=" NOTICE  "
            COLOR="$BLUE"
            ;;
    INFO )
            STATUS="  INFO   "
            COLOR="$LIGHT_BLUE"
            ;;
    DEBUG )
            STATUS="  DEBUG  "
            COLOR="$DEFAULT"
            ;;

    OK  )
            STATUS="   OK    "
            COLOR="$GREEN"
            ;;
    NOT_OK)
            STATUS=" NOT OK  "
            COLOR="$RED"
            ;;

    PASSED )
            STATUS=" PASSED  "
            COLOR="$GREEN"
            ;;

    SUCCESS )
            STATUS=" SUCCESS "
            COLOR="$GREEN"
            ;;

    FAILURE | FAILED )
            STATUS=" FAILED  "
            COLOR="$RED"
            ;;

    *)
            STATUS="UNDEFINED"
            COLOR="$YELLOW"
    esac

    raw_status "$STATUS" "$COLOR"
}

#
# Exit with error status
#
bail () {

    ERROR="$?"
    MSG="$1"
    if [ ! "$ERROR" = "0" ]
    then
        msg_fail "$MSG"
        exit "$ERROR"
    fi
}

#
# This function executes a command provided as a parameter
# The function then displays if the command succeeded or not.
#
cmd () {
    COMMAND="$@"

    msg "RUN -> $COMMAND"

    RESULT=$("$@" 2>&1)
    ERROR=$?

    check_status " ${COMMAND}" "${ERROR}"

    die_if_false $ERROR "$RESULT"

    return $ERROR
}

#
# These functions can be used for timing how long (a) command(s) take to
# execute.
#
now () {

    echo $(date +"%m-%d-%Y %T")
}

elapsed () {

    START="$1"
    STOP="$2"

    echo $(( STOP - START ))
}

#
# returns 0 if first parameter is an integer
# returns 1 otherwise
#
is_integer() {
  # Is it non-empty?
  # Is it the same after removing the letters?
  # If it is then it is an integer
  if [[ -n "$1" ]] && [[ "$1" == "${1//[^0-9]/}" ]]; then
    return 0
  fi
  return 1
}

# Example:
# arr=(a b c "d e" f g)
# array_contains arr "a b"  && echo yes || echo no    # no
# array_contains arr "d e"  && echo yes || echo no    # yes
array_contains() {
    local array="$1[@]"
    local seeking=$2
    local in=1
    for element in "${!array}"; do
        if [[ $element == $seeking ]]; then
            in=0
            break
        fi
    done
    return $in
}

# parameters: max # attempts to try, Amount of time to sleep between attempts, command
retry_until() {
  let max_attempts=$1
  if ! is_integer $max_attempts; then
    msg_fail "Invalid value for max_attempts. Must be integer."
    exit 1
  fi
  let sleep_time=$2
  if ! is_integer $sleep_time; then
    msg_fail "Invalid value for sleep_time. Must be integer."
    exit 1
  fi
  # pop them off
  shift; shift

  COMMAND="$@"

  COUNTER=0
  ERROR=1
  while [[ $COUNTER -lt $max_attempts ]]; do
    let COUNTER=COUNTER+1

    msg "RUN    -> $COMMAND"

    RESULT=$("$@" 2>&1)
    ERROR=$?

    if [ "$ERROR" != "0" ]; then
      msg_fail "$RESULT"
      echo ''
    fi
    check_status " ${COMMAND}" "${ERROR}"

    if [ "$ERROR" != "0" ]; then
      sleep $sleep_time  # Pause before retry
    else
      break
    fi
  done
  return $ERROR
}

#
# Prints an error message ($2) to stderr and exits with the return code ($1).
# The message is also logged.
#
function die {
    local -r err_code="$1"
    local -r err_msg="$2"
    local -r err_caller="${3:-$(caller 0)}"

    msg_fail "ERROR: $err_msg"
    msg_fail "ERROR: At line $err_caller"
    msg_fail "ERROR: Error code = $err_code"
    msg_fail "ERROR: Backtrace:"
    i=1
    while caller $i
    do
      i=$((i+1))
    done
    exit "$err_code"
} >&2 # function writes to stderr

#
# Check if a return code ($1) indicates an error (i.e. >0) and prints an error
# message ($2) to stderr and exits with the return code ($1).
# The error is also logged.
#
# Die if error code is false.
#
function die_if_false {
    local -r err_code=$1
    local -r err_msg=$2
    local -r err_caller=$(caller 0)

    if [[ "$err_code" != "0" ]]
    then
        die $err_code "$err_msg" "$err_caller"
    fi
} >&2 # function writes to stderr

#
# Dies when error code is true
#
function die_if_true {
    local -r err_code=$1
    local -r err_msg=$2
    local -r err_caller=$(caller 0)

    if [[ "$err_code" == "0" ]]
    then
        die $err_code "$err_msg" "$err_caller"
    fi
} >&2 # function writes to stderr

#
# Replace some text inside a string.
#
function str_replace () {
    local ORIG="$1"
    local DEST="$2"
    local DATA="$3"

    echo "$DATA" | sed "s/$ORIG/$DEST/g"
}

#
# Replace string of text in file.
# Uses the ed editor to replace the string.
#
# arg1 = string to be matched
# arg2 = new string that replaces matched string
# arg3 = file to operate on.
#
function str_replace_in_file () {
    local ORIG="$1"
    local DEST="$2"
    local FILE="$3"

    has_value FILE
    die_if_false $? "Empty argument 'file'"
    file_exists "$FILE"
    die_if_false $? "File does not exist"

    printf ",s/$ORIG/$DEST/g\nw\nQ" | ed -s "$FILE" > /dev/null 2>&1
    return "$?"
}

init
